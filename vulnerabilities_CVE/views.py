from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView
from django.utils import timezone
from django.db.models import Count
from django.conf import settings
from django.core.cache import cache
import requests
from .models import Vulnerability


# GET: ALL CVE 
class VulnerabilityNISTListAPIView(APIView):
    def get(self, request, *args, **kwargs):
        cached_vulnerabilities = cache.get('nist_vulnerabilities')

        if cached_vulnerabilities:
            return Response(cached_vulnerabilities, status=200)

        # Si no hay caché, consultar la API del NIST
        nist_api_url = 'https://services.nvd.nist.gov/rest/json/cves/2.0'
        api_key = settings.NIST_API_KEY
        headers = {
            'apiKey': api_key
        }

        try:
            response = requests.get(nist_api_url, headers=headers)
            response.raise_for_status()  # Check for HTTP errors
            response_data = response.json()

            vulnerabilities_data = []
            for item in response_data.get('vulnerabilities', []):
                cve_id = item['cve']['id']
                description = item['cve']['descriptions'][0]['value']
                severity = item['cve']['metrics']['cvssMetricV2'][0]['baseSeverity'] if 'cvssMetricV2' in item['cve']['metrics'] else 'Unknown'

                vulnerability, created = Vulnerability.objects.get_or_create(cve_id=cve_id)
                vulnerability.description = description
                vulnerability.severity = severity

                if not vulnerability.is_fixed:
                    vulnerability.is_fixed = False
                vulnerability.save()

                vulnerabilities_data.append({
                    'cve_id': cve_id,
                    'description': description,
                    'severity': severity,
                    'is_fixed': vulnerability.is_fixed
                })

            # Guardar los datos en caché por 24 horas
            cache.set('nist_vulnerabilities', vulnerabilities_data, timeout=86400)

            return Response(vulnerabilities_data, status=response.status_code)

        except requests.exceptions.RequestException as req_err:
            return Response({'error': f'An error occurred: {req_err}'}, status=500)

# POST: Mark vulnerabilities as fixed or unfixed
class FixVulnerabilitiesAPIView(APIView):
    def post(self, request, *args, **kwargs):
        cve_ids = request.data.get('cve_ids', [])
        new_fixed_status = request.data.get('is_fixed')

        if not cve_ids or new_fixed_status is None:
            return Response({'error': 'Faltan CVEs o el estado de fix.'}, status=status.HTTP_400_BAD_REQUEST)

        vulnerabilities = Vulnerability.objects.filter(cve_id__in=cve_ids)

        if not vulnerabilities.exists():
            return Response({'error': 'No se encontraron vulnerabilidades con los CVEs proporcionados.'}, status=status.HTTP_404_NOT_FOUND)

        updated_vulnerabilities = []
        for vulnerability in vulnerabilities:
            if vulnerability.is_fixed != new_fixed_status:
                vulnerability.is_fixed = new_fixed_status
                vulnerability.fixed_date = timezone.now() if new_fixed_status else None
                vulnerability.save()
                updated_vulnerabilities.append(vulnerability.cve_id)

        cached_vulnerabilities = cache.get('nist_vulnerabilities')
        if cached_vulnerabilities:
            for cached_vul in cached_vulnerabilities:
                if cached_vul['cve_id'] in updated_vulnerabilities:
                    cached_vul['is_fixed'] = new_fixed_status

            cache.set('nist_vulnerabilities', cached_vulnerabilities, timeout=86400)

        return Response({'message': 'Vulnerabilidades actualizadas y caché sincronizado.'}, status=status.HTTP_200_OK)

# GET: Get a specific CVE by ID
class VulnerabilityDetailAPIView(APIView):
    def get(self, request, cve_id, *args, **kwargs):
        try:
            vulnerability = Vulnerability.objects.get(cve_id=cve_id)
            data = {
                'cve_id': vulnerability.cve_id,
                'description': vulnerability.description,
                'severity': vulnerability.severity,
                'is_fixed': vulnerability.is_fixed,
                'fixed_date': vulnerability.fixed_date
            }
            return Response(data, status=status.HTTP_200_OK)
        except Vulnerability.DoesNotExist:
            return Response({'error': 'Vulnerabilidad no encontrada.'}, status=status.HTTP_404_NOT_FOUND)

# GET: Unfixed vulnerabilities
class UnfixedVulnerabilitiesAPIView(APIView):
    def get(self, request, *args, **kwargs):
        vulnerabilities = Vulnerability.objects.filter(is_fixed=False)
        data = [
            {
                'cve_id': vulnerability.cve_id,
                'description': vulnerability.description,
                'severity': vulnerability.severity
            }
            for vulnerability in vulnerabilities
        ]
        return Response(data, status=status.HTTP_200_OK)

# GET: Fixed vulnerabilities
class FixedVulnerabilitiesAPIView(APIView):
    def get(self, request, *args, **kwargs):
        vulnerabilities = Vulnerability.objects.filter(is_fixed=True)
        data = [
            {
                'cve_id': vulnerability.cve_id,
                'description': vulnerability.description,
                'severity': vulnerability.severity,
                'fixed_date': vulnerability.fixed_date
            }
            for vulnerability in vulnerabilities
        ]
        return Response(data, status=status.HTTP_200_OK)

# GET: Summary by severity
class SeveritySummaryAPIView(APIView):
    def get(self, request, *args, **kwargs):
        severity_summary = Vulnerability.objects.values('severity').annotate(count=Count('severity'))
        return Response(severity_summary, status=status.HTTP_200_OK)
